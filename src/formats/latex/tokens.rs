use super::grammar::*;

use crate::arity::Arity;
use crate::expression::*;

use std::collections::{HashMap, HashSet};

#[derive(Copy,Clone,Eq,PartialEq,Ord,PartialOrd,Hash,Debug)]
pub(crate) enum Token<'a> {
    Symbol(&'a [u8]),
    Integer(&'a [u8]),
    Real(&'a [u8]),
    Static(StaticToken),
}

#[derive(Copy,Clone,Eq,PartialEq,Ord,PartialOrd,Hash,Debug)]
pub(crate) enum StaticToken {
    Sum,
    D,
    // I,
    // E,
    Pi,
    Product,
    // AddTo,
    And,
    LeftAngleBracket,
    RightAngleBracket,
    // Backslash,
    Because,
    DoubleFactorial,
    LeftBracket,
    RightBracket,
    LeftBrace,
    RightBrace,
    LeftList,
    RightList,
    // Cap,
    //CapitalDifferentialD,
    LeftCeiling,
    RightCeiling,
    CenterDot,
    CircleDot,
    CircleMinus,
    CirclePlus,
    CircleTimes,
    Colon,
    Comma,
    Semicolon,
    //Conditioned,
    Congruent,
    // Conjugate,
    ConjugateTranspose,
    //ContinuedFractionK,
    // Coproduct,
    // Cross,
    // Cup,
    // CupCap,
    //Decrement,
    // Degree,
    Del,
    // Diamond,
    //DifferenceDelta,
    //DirectedEdge,
    //Distributed,
    Divide,
    // DivideBy,
    Dot,
    // DotEqual,
    // LeftDoubleBracketingBar,
    // RightDoubleBracketingBar,
    // DoubleDownArrow,
    // DoubleLeftTee,
    // DoubleRightTee,
    // DoubleUpArrow,
    // DoubleVerticalBar,
    // DownArrow,
    // DownArrowBar,
    // DownLeftRightVector,
    // DownLeftTeeVector,
    // DownLeftVector,
    // DownLeftVectorBar,
    // DownRightTeeVector,
    // DownRightVector,
    // DownRightVectorBar,
    // DownTee,
    // DownTeeArrow,
    Element,
    Equal,
    // EqualTilde,
    // Equilibrium,
    Equivalent,
    Exists,
    Frac,
    LeftFloor,
    RightFloor,
    ForAll,
    // Function,
    // Get,
    Greater,
    GreaterEqual,
    // GreaterEqualLess,
    // GreaterFullEqual,
    GreaterGreater,
    // GreaterLess,
    // GreaterSlantEqual,
    GreaterSim,
    // HumpDownHump,
    // HumpEqual,
    Implies,
    // Increment,
    Infinity,
    Integrate,
    Intersection,
    // LeftDownTeeVector,
    // LeftDownVector,
    // LeftDownVectorBar,
    // LeftRightVector,
    // LeftTee,
    // LeftTeeVector,
    // LeftTriangle,
    // LeftTriangleBar,
    // LeftTriangleEqual,
    // LeftUpDownVector,
    // LeftUpTeeVector,
    // LeftUpVector,
    // LeftUpVectorBar,
    // LeftVector,
    // LeftVectorBar,
    Less,
    LessEqual,
    // LessEqualGreater,
    // LessFullEqual,
    LessGreater,
    LessLess,
    // LessSlantEqual,
    LessSim,
    Limit,
    // LeftList,
    // RightList,
    // MaxLimit,
    // MinLimit,
    MinusPlus,
    // NestedGreaterGreater,
    // NestedLessLess,
    // NonCommutativeMultiply,
    // Nor,
    Not,
    // NotCongruent,
    // NotCupCap,
    // NotDoubleVerticalBar,
    NotElement,
    NotExists,
    NotGreater,
    NotGreaterEqual,
    // NotGreaterFullEqual,
    NotGreaterGreater,
    // NotGreaterLess,
    // NotGreaterSlantEqual,
    NotGreaterSim,
    // NotHumpDownHump,
    // NotHumpEqual,
    // NotLeftTriangle,
    // NotLeftTriangleBar,
    // NotLeftTriangleEqual,
    NotLess,
    NotLessEqual,
    // NotLessFullEqual,
    // NotLessGreater,
    NotLessLess,
    // NotLessSlantEqual,
    NotLessSim,
    // NotNestedGreaterGreater,
    // NotNestedLessLess,
    // NotPrecedes,
    // NotPrecedesEqual,
    // NotPrecedesSlantEqual,
    // NotPrecedesTilde,
    // NotReverseElement,
    // NotRightTriangle,
    // NotRightTriangleBar,
    // NotRightTriangleEqual,
    // NotSquareSubset,
    // NotSquareSubsetEqual,
    // NotSquareSuperset,
    // NotSquareSupersetEqual,
    // NotSubset,
    NotSubsetEqual,
    // NotSucceeds,
    // NotSucceedsEqual,
    // NotSucceedsSlantEqual,
    // NotSucceedsTilde,
    // NotSuperset,
    NotSupersetEqual,
    // NotTilde,
    // NotTildeEqual,
    // NotTildeFullEqual,
    // NotTildeTilde,
    // NotVerticalBar,
    Or,
    Plus,
    PlusMinus,
    Power,
    // Precedes,
    // PrecedesEqual,
    // PrecedesSlantEqual,
    // PrecedesTilde,
    // Proportion,
    Proportional,
    // ReverseElement,
    // ReverseEquilibrium,
    // ReverseUpEquilibrium,
    // RightDownTeeVector,
    // RightDownVector,
    // RightDownVectorBar,
    // RightTee,
    // RightTeeVector,
    // RightTriangle,
    // RightTriangleBar,
    // RightTriangleEqual,
    // RightUpDownVector,
    // RightUpTeeVector,
    // RightUpVector,
    // RightUpVectorBar,
    // RightVector,
    // RightVectorBar,
    // SmallCircle,
    Sqrt,
    // Square,
    // LeftSquareBracket,
    // RightSquareBracket,
    // SquareIntersection,
    // SquareSubset,
    // SquareSubsetEqual,
    // SquareSuperset,
    // SquareSupersetEqual,
    // SquareUnion,
    // Star,
    Subset,
    SubsetEqual,
    Minus,
    // Succeeds,
    // SucceedsEqual,
    // SucceedsSlantEqual,
    // SucceedsTilde,
    // SuchThat,
    Superset,
    SupersetEqual,
    Therefore,
    Sim,
    SimEqual,
    // SimFullEqual,
    Approx,
    Times,
    // Transpose,
    // UndirectedEdge,
    Unequal,
    Union,
    // UnionPlus,
    // UnsameQ,
    // UpArrow,
    // UpArrowBar,
    // UpEquilibrium,
    // UpTee,
    // VectorGreater,
    // VectorGreaterEqual,
    // VectorLess,
    // VectorLessEqual,
    Vee,
    // VerticalBar,
    // VerticalSeparator,
    // VerticalTilde,
    Wedge,
    // Xnor,
    // Xor,
    Log,
    Exp,
    Sin,
    Cos,
    Tan,
    Sinh,
    Cosh,
    Tanh,
    ArcSin,
    ArcCos,
    ArcTan,
    // ArcSinh,
    // ArcCosh,
    // ArcTanh,
    Subscript,
}

lazy_static!{
    pub(crate) static ref MAX_TOKEN_STR_LEN: usize = BUILTIN.keys().map(|k| k.len()).max().unwrap();
}

pub(crate) const BUILTIN: phf::Map<&'static [u8], StaticToken> = phf_map!{
    br"\sum" => StaticToken::Sum,
    br"\partial" => StaticToken::D,
    // I,
    // E,
    br"\pi" => StaticToken::Pi,
    br"\prod" => StaticToken::Product,
    br"\land" => StaticToken::And,
    br"\langle" => StaticToken::LeftAngleBracket,
    br"\rangle" => StaticToken::RightAngleBracket,
    br"\because" => StaticToken::Because,
    br"!!" => StaticToken::DoubleFactorial,
    br"(" => StaticToken::LeftBracket,
    br"[" => StaticToken::LeftBracket,
    br"{" => StaticToken::LeftBrace,
    br"\{" => StaticToken::LeftList,
    br")" => StaticToken::RightBracket,
    br"]" => StaticToken::RightBracket,
    br"}" => StaticToken::RightBrace,
    br"\}" => StaticToken::RightList,
    br"\cup" => StaticToken::Union,
    br"\bigcup" => StaticToken::Union,
    br"\lceil" => StaticToken::LeftCeiling,
    br"\rceil" => StaticToken::RightCeiling,
    br"\cdot" => StaticToken::CenterDot,
    br"\odot" => StaticToken::CircleDot,
    br"\bigodot" => StaticToken::CircleDot,
    br"\ominus" => StaticToken::CircleMinus,
    br"\oplus" => StaticToken::CirclePlus,
    br"\bigoplus" => StaticToken::CirclePlus,
    br"\otimes" => StaticToken::CircleTimes,
    br"\bigotimes" => StaticToken::CircleTimes,
    br":" => StaticToken::Colon,
    br"," => StaticToken::Comma,
    br";" => StaticToken::Semicolon,
    br"\cong" => StaticToken::Congruent,
    //Conjugate,
    br"\dagger" => StaticToken::ConjugateTranspose,
    //Coproduct,
    //Cross,
    //Degree,
    br"\nabla" => StaticToken::Del,
    br"/" => StaticToken::Divide,
    br"\over" => StaticToken::Divide,
    br"." => StaticToken::Dot,
    br"\in" => StaticToken::Element,
    br"=" => StaticToken::Equal,
    br"\equiv" => StaticToken::Equivalent,
    br"\exists" => StaticToken::Exists,
    br"\frac" => StaticToken::Frac,
    br"\lfloor" => StaticToken::LeftFloor,
    br"\rfloor" => StaticToken::RightFloor,
    br"\forall" => StaticToken::ForAll,
    br">" => StaticToken::Greater,
    br"\ge" => StaticToken::GreaterEqual,
    br"\geq" => StaticToken::GreaterEqual,
    br"\gg" => StaticToken::GreaterGreater,
    br"\gtrsim" => StaticToken::GreaterSim,
    br"\Rightarrow" => StaticToken::Implies,
    br"\infty" => StaticToken::Infinity,
    br"\int" => StaticToken::Integrate,
    br"\cap" => StaticToken::Intersection,
    br"\bigcap" => StaticToken::Intersection,
    br"<" => StaticToken::Less,
    br"\le" => StaticToken::LessEqual,
    br"\leq" => StaticToken::LessEqual,
    br"\lessgtr" => StaticToken::LessGreater,
    br"\ll" => StaticToken::LessLess,
    br"\lessim" => StaticToken::LessSim,
    br"\lim" => StaticToken::Limit,
    br"\mp" => StaticToken::MinusPlus,
    br"\lnot" => StaticToken::Not,
    br"\neg" => StaticToken::Not,
    br"\notin" => StaticToken::NotElement,
    br"\not\in" => StaticToken::NotElement,
    br"\nexists" => StaticToken::NotExists,
    br"\ngtr" => StaticToken::NotGreater,
    br"\ngeq" => StaticToken::NotGreaterEqual,
    br"\not\gg" => StaticToken::NotGreaterGreater,
    br"\gnsim" => StaticToken::NotGreaterSim,
    br"\nless" => StaticToken::NotLess,
    br"\nleq" => StaticToken::NotLessEqual,
    br"\not\ll" => StaticToken::NotLessLess,
    br"\lnsim" => StaticToken::NotLessSim,
    br"\nsubseteq" => StaticToken::NotSubsetEqual,
    br"\subsetneq" => StaticToken::NotSubsetEqual,
    br"\varsubsetneq" => StaticToken::NotSubsetEqual,
    br"\nsupseteq" => StaticToken::NotSupersetEqual,
    br"\supsetneq" => StaticToken::NotSupersetEqual,
    br"\varsupsetneq" => StaticToken::NotSupersetEqual,
    br"\lor" => StaticToken::Or,
    br"+" => StaticToken::Plus,
    br"\pm" => StaticToken::PlusMinus,
    br"^" => StaticToken::Power,
    br"\propto" => StaticToken::Proportional,
    br"\sqrt" => StaticToken::Sqrt,
    br"\subset" => StaticToken::Subset,
    br"\subseteq" => StaticToken::SubsetEqual,
    br"-" => StaticToken::Minus,
    br"\supset" => StaticToken::Superset,
    br"\supseteq" => StaticToken::SupersetEqual,
    br"\therefore" => StaticToken::Therefore,
    br"\sim" => StaticToken::Sim,
    br"\simeq" => StaticToken::SimEqual,
    br"\approx" => StaticToken::Approx,
    br"\*" => StaticToken::Times,
    br"\times" => StaticToken::Times,
    br"\ne" => StaticToken::Unequal,
    br"\neq" => StaticToken::Unequal,
    br"\wedge" => StaticToken::Wedge,
    br"\ln" => StaticToken::Log,
    br"\log" => StaticToken::Log,
    br"\exp" => StaticToken::Exp,
    br"\sin" => StaticToken::Sin,
    br"\cos" => StaticToken::Cos,
    br"\tan" => StaticToken::Tan,
    br"\sinh" => StaticToken::Sinh,
    br"\cosh" => StaticToken::Cosh,
    br"\tanh" => StaticToken::Tanh,
    br"\arcsin" => StaticToken::ArcSin,
    br"\arccos" => StaticToken::ArcCos,
    br"\arctan" => StaticToken::ArcTan,
    br"_" => StaticToken::Subscript,
    br"\vee" => StaticToken::Vee,
};


lazy_static! {
    pub(crate) static ref TOKEN_PREC: HashMap<StaticToken, u32> = hashmap!{
        StaticToken::Product => PREC_PRODUCT,
        StaticToken::And => PREC_AND,
        StaticToken::LeftAngleBracket => PREC_LEFT_ANGLE_BRACKET,
        StaticToken::RightAngleBracket => PREC_RIGHT_ANGLE_BRACKET,
        // StaticToken::Backslash => PREC_BACKSLASH,
        StaticToken::Because => PREC_BECAUSE,
        StaticToken::LeftBracket => PREC_LEFT_BRACKET,
        StaticToken::LeftBrace => PREC_LEFT_BRACKET,
        StaticToken::RightBracket => PREC_RIGHT_BRACKET,
        StaticToken::RightBrace => PREC_RIGHT_BRACKET,
        StaticToken::LeftCeiling => PREC_LEFT_CEILING,
        StaticToken::RightCeiling => PREC_RIGHT_CEILING,
        StaticToken::CircleMinus => PREC_CIRCLE_MINUS,
        StaticToken::CirclePlus => PREC_CIRCLE_PLUS,
        StaticToken::CircleTimes => PREC_CIRCLE_TIMES,
        StaticToken::Colon => PREC_COLON,
        StaticToken::Comma => PREC_SEQUENCE,
        StaticToken::Semicolon => PREC_COMPOUND_EXPRESSION,
        // StaticToken::Conjugate => PREC_CONJUGATE,
        StaticToken::ConjugateTranspose => PREC_CONJUGATE_TRANSPOSE,
        StaticToken::Del => PREC_DEL,
        StaticToken::Divide => PREC_DIVIDE,
        StaticToken::Dot => PREC_DOT,
        StaticToken::DoubleFactorial => PREC_FACTORIAL2,
        StaticToken::Element => PREC_ELEMENT,
        StaticToken::Equal => PREC_EQUAL,
        StaticToken::Equivalent => PREC_EQUIVALENT,
        StaticToken::Exists => PREC_EXISTS,
        StaticToken::LeftFloor => PREC_LEFT_FLOOR,
        StaticToken::RightFloor => PREC_RIGHT_FLOOR,
        StaticToken::ForAll => PREC_FOR_ALL,
        StaticToken::Greater => PREC_GREATER,
        StaticToken::GreaterEqual => PREC_GREATER_EQUAL,
        // StaticToken::GreaterEqualLess => PREC_GREATER_EQUAL,
        // StaticToken::GreaterFullEqual => PREC_GREATER_EQUAL,
        StaticToken::GreaterGreater => PREC_GREATER,
        // StaticToken::GreaterLess => PREC_GREATER,
        // StaticToken::GreaterSlantEqual => PREC_GREATER,
        StaticToken::GreaterSim => PREC_GREATER,
        StaticToken::Implies => PREC_IMPLIES,
        StaticToken::Infinity => PREC_SYMBOL,
        StaticToken::Integrate => PREC_INTEGRATE,
        StaticToken::Intersection => PREC_INTERSECTION,
        StaticToken::Less => PREC_LESS,
        StaticToken::LessEqual => PREC_LESS_EQUAL,
        // StaticToken::LessEqualGreater => PREC_LESS_EQUAL,
        // StaticToken::LessFullEqual => PREC_LESS_EQUAL,
        StaticToken::LessGreater => PREC_LESS,
        StaticToken::LessLess => PREC_LESS,
        StaticToken::LessSim => PREC_LESS,
        StaticToken::Limit => PREC_LIMIT,
        StaticToken::LeftList => PREC_LEFT_CURLY_BRACKET,
        StaticToken::RightList => PREC_RIGHT_CURLY_BRACKET,
        StaticToken::MinusPlus => PREC_MINUS_PLUS,
        StaticToken::Not => PREC_FACTORIAL,
        StaticToken::NotElement => PREC_ELEMENT,
        StaticToken::NotExists => PREC_EXISTS,
        StaticToken::NotGreater => PREC_GREATER,
        StaticToken::NotGreaterEqual => PREC_GREATER_EQUAL,
        // StaticToken::NotGreaterFullEqual => PREC_GREATER_EQUAL,
        StaticToken::NotGreaterGreater => PREC_GREATER,
        // StaticToken::NotGreaterLess => PREC_GREATER,
        // StaticToken::NotGreaterSlantEqual => PREC_GREATER_EQUAL,
        StaticToken::NotGreaterSim => PREC_GREATER_EQUAL,
        StaticToken::NotLess => PREC_LESS,
        StaticToken::NotLessEqual => PREC_LESS_EQUAL,
        // StaticToken::NotLessFullEqual => PREC_LESS_EQUAL,
        // StaticToken::NotLessGreater => PREC_LESS,
        StaticToken::NotLessLess => PREC_LESS,
        // StaticToken::NotLessSlantEqual => PREC_LESS_EQUAL,
        StaticToken::NotLessSim => PREC_LESS,
        // StaticToken::NotNestedGreaterGreater => PREC_GREATER,
        // StaticToken::NotNestedLessLess => PREC_LESS,
        // StaticToken::NotSubset => PREC_SUBSET,
        // StaticToken::NotSuperset => PREC_SUPERSET,
        StaticToken::Or => PREC_OR,
        StaticToken::Plus => PREC_PLUS,
        StaticToken::Minus => PREC_MINUS,
        StaticToken::PlusMinus => PREC_PLUS_MINUS,
        StaticToken::Power => PREC_POWER,
        StaticToken::Sqrt => PREC_SQRT,
        StaticToken::D => PREC_D,
        StaticToken::Subset => PREC_SUBSET,
        // StaticToken::SuchThat => PREC_SUCH_THAT,
        StaticToken::Superset => PREC_SUPERSET,
        StaticToken::Therefore => PREC_THEREFORE,
        StaticToken::Times => PREC_TIMES,
        StaticToken::Unequal => PREC_UNEQUAL,
        StaticToken::Union => PREC_UNION,
        StaticToken::Wedge => PREC_WEDGE,
        // StaticToken::Xnor => PREC_XNOR,
        // StaticToken::Xor => PREC_XOR,
        StaticToken::Log => PREC_SYMBOL,
        StaticToken::Exp => PREC_SYMBOL,
        StaticToken::Sin => PREC_SYMBOL,
        StaticToken::Cos => PREC_SYMBOL,
        StaticToken::Tan => PREC_SYMBOL,
        StaticToken::Sinh => PREC_SYMBOL,
        StaticToken::Cosh => PREC_SYMBOL,
        StaticToken::Tanh => PREC_SYMBOL,
        StaticToken::ArcSin => PREC_SYMBOL,
        StaticToken::ArcCos => PREC_SYMBOL,
        StaticToken::ArcTan => PREC_SYMBOL,
        StaticToken::Subscript => PREC_SUBSCRIPT,
    };
}


lazy_static! {
    pub(crate) static ref UNKNOWN_TOKEN_PREC: HashSet<StaticToken> = hashset!{
        StaticToken::Sim,
        StaticToken::SupersetEqual,
        StaticToken::SimEqual,
        StaticToken::Sum,
        StaticToken::CenterDot,
        StaticToken::CircleDot,
        StaticToken::NotSubsetEqual,
        StaticToken::NotSupersetEqual,
        StaticToken::Proportional,
        StaticToken::SubsetEqual,
        StaticToken::Congruent,
        StaticToken::Vee,
    };
}

// arity for "operators" that can appear in the call to the `null`  method
// of the Pratt parser, i.e. nullary, unary prefix, or brackets
lazy_static! {
    pub(crate) static ref NULL_ARITY: HashMap<StaticToken, Arity> = hashmap!{
        //nullary operators
        StaticToken::Pi => Arity::Nullary,
        StaticToken::Infinity => Arity::Nullary,
        StaticToken::Log => Arity::Nullary,
        StaticToken::Exp => Arity::Nullary,
        StaticToken::Sin => Arity::Nullary,
        StaticToken::Cos => Arity::Nullary,
        StaticToken::Tan => Arity::Nullary,
        StaticToken::Sinh => Arity::Nullary,
        StaticToken::Cosh => Arity::Nullary,
        StaticToken::Tanh => Arity::Nullary,
        StaticToken::ArcSin => Arity::Nullary,
        StaticToken::ArcCos => Arity::Nullary,
        StaticToken::ArcTan => Arity::Nullary,

        // brackets
        StaticToken::LeftAngleBracket => Arity::Unary,
        StaticToken::LeftBracket => Arity::Unary,
        StaticToken::LeftBrace => Arity::Unary,
        StaticToken::LeftCeiling => Arity::Unary,
        StaticToken::LeftFloor => Arity::Unary,
        StaticToken::LeftList => Arity::Unary,

        // unary (prefix) operators
        StaticToken::Sqrt => Arity::Unary,
        StaticToken::Del => Arity::Unary,
        StaticToken::D => Arity::Unary,
        StaticToken::Exists => Arity::Unary,
        StaticToken::ForAll => Arity::Unary,
        StaticToken::MinusPlus => Arity::Unary,
        StaticToken::Not => Arity::Unary,
        StaticToken::NotExists => Arity::Unary,
        StaticToken::Plus => Arity::Unary,
        StaticToken::PlusMinus => Arity::Unary,
        StaticToken::Minus => Arity::Unary,
        StaticToken::MinusPlus => Arity::Unary,
        //StaticToken::Sqrt => Arity::Unary,
    };
}

// arity for operators that can appear in the call to the `left`  method
// of the Pratt parser, i.e. unary postfix, binary, or function-like
lazy_static! {
    pub(crate) static ref LEFT_ARITY: HashMap<StaticToken, Arity> = hashmap!{
        StaticToken::LeftBracket => Arity::Function,

        StaticToken::LeftBrace => Arity::Unary,
        StaticToken::DoubleFactorial => Arity::Unary,
        StaticToken::ConjugateTranspose => Arity::Unary,

        StaticToken::And => Arity::Binary,
        StaticToken::Because => Arity::Binary,
        StaticToken::RightBracket => Arity::Binary,
        StaticToken::CenterDot => Arity::Binary,
        StaticToken::CircleDot => Arity::Binary,
        StaticToken::CircleMinus => Arity::Binary,
        StaticToken::CirclePlus => Arity::Binary,
        StaticToken::CircleTimes => Arity::Binary,
        StaticToken::Colon => Arity::Binary,
        StaticToken::Comma => Arity::Binary,
        StaticToken::Semicolon => Arity::Binary,
        StaticToken::Congruent => Arity::Binary,
        StaticToken::Divide => Arity::Binary,
        StaticToken::Dot => Arity::Binary,
        StaticToken::Element => Arity::Binary,
        StaticToken::Equal => Arity::Binary,
        StaticToken::Equivalent => Arity::Binary,
        StaticToken::Greater => Arity::Binary,
        StaticToken::GreaterEqual => Arity::Binary,
        StaticToken::GreaterGreater => Arity::Binary,
        StaticToken::GreaterSim => Arity::Binary,
        StaticToken::Implies => Arity::Binary,
        StaticToken::Intersection => Arity::Binary,
        StaticToken::Less => Arity::Binary,
        StaticToken::LessEqual => Arity::Binary,
        StaticToken::LessGreater => Arity::Binary,
        StaticToken::LessLess => Arity::Binary,
        StaticToken::LessSim => Arity::Binary,
        StaticToken::MinusPlus => Arity::Binary,
        StaticToken::NotElement => Arity::Binary,
        StaticToken::NotGreater => Arity::Binary,
        StaticToken::NotGreaterEqual => Arity::Binary,
        StaticToken::NotGreaterGreater => Arity::Binary,
        StaticToken::NotGreaterSim => Arity::Binary,
        StaticToken::NotLess => Arity::Binary,
        StaticToken::NotLessEqual => Arity::Binary,
        StaticToken::NotLessLess => Arity::Binary,
        StaticToken::NotLessSim => Arity::Binary,
        StaticToken::NotSubsetEqual => Arity::Binary,
        StaticToken::NotSupersetEqual => Arity::Binary,
        StaticToken::Or => Arity::Binary,
        StaticToken::Plus => Arity::Binary,
        StaticToken::PlusMinus => Arity::Binary,
        StaticToken::Power => Arity::Binary,
        StaticToken::Proportional => Arity::Binary,
        StaticToken::Subset => Arity::Binary,
        StaticToken::SubsetEqual => Arity::Binary,
        StaticToken::Minus => Arity::Binary,
        StaticToken::Superset => Arity::Binary,
        StaticToken::SupersetEqual => Arity::Binary,
        StaticToken::Therefore => Arity::Binary,
        StaticToken::Sim => Arity::Binary,
        StaticToken::SimEqual => Arity::Binary,
        StaticToken::Approx => Arity::Binary,
        StaticToken::Times => Arity::Binary,
        StaticToken::Unequal => Arity::Binary,
        StaticToken::Union => Arity::Binary,
        StaticToken::Vee => Arity::Binary,
        StaticToken::Wedge => Arity::Binary,
        StaticToken::Subscript => Arity::Binary,
    };
}

lazy_static! {
    pub(crate) static ref CLOSING_BRACKET: HashMap<StaticToken, StaticToken> = hashmap!{
        StaticToken::LeftAngleBracket  => StaticToken::RightAngleBracket,
        StaticToken::LeftBracket       => StaticToken::RightBracket,
        StaticToken::LeftBrace         => StaticToken::RightBrace,
        StaticToken::LeftCeiling       => StaticToken::RightCeiling,
        StaticToken::LeftFloor         => StaticToken::RightFloor,
        StaticToken::LeftList          => StaticToken::RightList,
    };
}

lazy_static! {
    pub(crate) static ref TOKEN_EXPRESSION: HashMap<StaticToken, NullaryOp<'static>> = hashmap!{
        StaticToken::Pi => NullaryOp::Pi,
        StaticToken::Infinity => NullaryOp::Infinity,
        StaticToken::Log => NullaryOp::Log,
        StaticToken::Exp => NullaryOp::Exp,
        StaticToken::Sin => NullaryOp::Sin,
        StaticToken::Cos => NullaryOp::Cos,
        StaticToken::Tan => NullaryOp::Tan,
        StaticToken::Sinh => NullaryOp::Sinh,
        StaticToken::Cosh => NullaryOp::Cosh,
        StaticToken::Tanh => NullaryOp::Tanh,
        StaticToken::ArcSin => NullaryOp::ASin,
        StaticToken::ArcCos => NullaryOp::ACos,
        StaticToken::ArcTan => NullaryOp::ATan,
        StaticToken::Sqrt => NullaryOp::Sqrt,
        StaticToken::Subscript => NullaryOp::Subscript,
    };
}

lazy_static! {
    pub(crate) static ref PREFIX_OP_TO_EXPR: HashMap<StaticToken, UnaryOp> = hashmap!{
        StaticToken::Del => UnaryOp::Del,
        StaticToken::Exists => UnaryOp::Exists,
        StaticToken::ForAll => UnaryOp::ForAll,
        StaticToken::MinusPlus => UnaryOp::UMinusPlus,
        StaticToken::Not => UnaryOp::Not,
        StaticToken::NotExists => UnaryOp::NotExists,
        StaticToken::Plus => UnaryOp::UPlus,
        StaticToken::PlusMinus => UnaryOp::UPlusMinus,
        StaticToken::Minus => UnaryOp::UMinus,
        StaticToken::MinusPlus => UnaryOp::UMinusPlus,
    };
}

lazy_static! {
    pub(crate) static ref POSTFIX_OP_TO_EXPR: HashMap<StaticToken, UnaryOp> = hashmap!{
        StaticToken::ConjugateTranspose => UnaryOp::ConjugateTranspose,
        // StaticToken::Degree => UnaryOp::Degree,
        StaticToken::Not => UnaryOp::Factorial,
        StaticToken::DoubleFactorial => UnaryOp::DoubleFactorial,
        // StaticToken::SuperDagger => UnaryOp::SuperDagger,
    };
}

lazy_static! {
    pub(crate) static ref BINARY_OP_TO_EXPR: HashMap<StaticToken, BinaryOp> = hashmap!{
        StaticToken::And => BinaryOp::And,
        // StaticToken::Backslash => BinaryOp::Backslash,
        StaticToken::Because => BinaryOp::Because,
        // StaticToken::Cap => BinaryOp::Cap,
        StaticToken::CenterDot => BinaryOp::CenterDot,
        StaticToken::CircleDot => BinaryOp::CircleDot,
        StaticToken::CircleMinus => BinaryOp::CircleMinus,
        StaticToken::CirclePlus => BinaryOp::CirclePlus,
        StaticToken::CircleTimes => BinaryOp::CircleTimes,
        StaticToken::Colon => BinaryOp::Colon,
        StaticToken::Comma => BinaryOp::Sequence,
        StaticToken::Semicolon => BinaryOp::Compound,
        StaticToken::Congruent => BinaryOp::Congruent,
        StaticToken::Divide => BinaryOp::Divide,
        StaticToken::Dot => BinaryOp::Dot,
        StaticToken::Element => BinaryOp::Element,
        StaticToken::Equal => BinaryOp::Equal,
        StaticToken::Equivalent => BinaryOp::Equivalent,
        StaticToken::Greater => BinaryOp::Greater,
        StaticToken::GreaterEqual => BinaryOp::GreaterEqual,
        StaticToken::GreaterGreater => BinaryOp::GreaterGreater,
        StaticToken::Implies => BinaryOp::Implies,
        StaticToken::Intersection => BinaryOp::Intersection,
        StaticToken::Less => BinaryOp::Less,
        StaticToken::LessEqual => BinaryOp::LessEqual,
        StaticToken::LessGreater => BinaryOp::LessGreater,
        StaticToken::LessLess => BinaryOp::LessLess,
        StaticToken::Limit => BinaryOp::Limit,
        StaticToken::LeftList => BinaryOp::LeftList,
        StaticToken::RightList => BinaryOp::RightList,
        StaticToken::MinusPlus => BinaryOp::MinusPlus,
        StaticToken::NotElement => BinaryOp::NotElement,
        StaticToken::NotGreater => BinaryOp::NotGreater,
        StaticToken::NotGreaterEqual => BinaryOp::NotGreaterEqual,
        StaticToken::NotGreaterGreater => BinaryOp::NotGreaterGreater,
        // StaticToken::NotGreaterSim => BinaryOp::NotGreaterSim,
        StaticToken::NotLess => BinaryOp::NotLess,
        StaticToken::NotLessEqual => BinaryOp::NotLessEqual,
        StaticToken::NotLessLess => BinaryOp::NotLessLess,
        // StaticToken::NotLessSim => BinaryOp::NotLessSim,
        StaticToken::NotSubsetEqual => BinaryOp::NotSubsetEqual,
        StaticToken::NotSupersetEqual => BinaryOp::NotSupersetEqual,
        StaticToken::Or => BinaryOp::Or,
        StaticToken::Plus => BinaryOp::Plus,
        StaticToken::PlusMinus => BinaryOp::PlusMinus,
        StaticToken::Power => BinaryOp::Power,
        StaticToken::Proportional => BinaryOp::Proportional,
        StaticToken::Subset => BinaryOp::Subset,
        StaticToken::SubsetEqual => BinaryOp::SubsetEqual,
        StaticToken::Minus => BinaryOp::Minus,
        // StaticToken::SuchThat => BinaryOp::SuchThat,
        StaticToken::Superset => BinaryOp::Superset,
        StaticToken::SupersetEqual => BinaryOp::SupersetEqual,
        StaticToken::Therefore => BinaryOp::Therefore,
        // StaticToken::Sim => BinaryOp::Sim,
        // StaticToken::SimEqual => BinaryOp::SimEqual,
        StaticToken::Times => BinaryOp::Times,
        StaticToken::Unequal => BinaryOp::Unequal,
        StaticToken::Union => BinaryOp::Union,
        StaticToken::Vee => BinaryOp::Vee,
        StaticToken::Wedge => BinaryOp::Wedge,
    };
}
